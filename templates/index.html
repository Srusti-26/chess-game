<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SRUSTI Chess</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&family=Playfair+Display:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --board-size: 480px;
            --square-size: calc(var(--board-size) / 8);
            --light-square: #f0e4d7;
            --dark-square: #7c5e48;
            --selected-color: rgba(72, 191, 227, 0.7);
            --valid-move-color: rgba(72, 191, 227, 0.5);
            --capture-move-color: rgba(235, 87, 87, 0.5);
            --castle-move-color: rgba(126, 217, 87, 0.5);
            --primary-color: #2d4059;
            --secondary-color: #ea5455;
            --accent-color: #48bfe3;
            --text-color: #2d4059;
            --light-text: #f0f0f0;
            --background-color: #f9f7f3;
            --gold: #ffd166;
            --frame-color: linear-gradient(135deg, #7c5e48, #4a2c16);
            --highlight-color: #48bfe3;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--background-color);
            color: var(--text-color);
            min-height: 100vh;
            padding: 20px;
            background-image: 
                radial-gradient(circle at 25px 25px, rgba(72, 191, 227, 0.15) 2%, transparent 0%), 
                radial-gradient(circle at 75px 75px, rgba(234, 84, 85, 0.1) 2%, transparent 0%);
            background-size: 100px 100px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            width: 100%;
            position: relative;
        }

        h1 {
            font-family: 'Playfair Display', serif;
            font-size: 3.5rem;
            margin-bottom: 10px;
            color: var(--primary-color);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            letter-spacing: 2px;
            position: relative;
            display: inline-block;
        }

        h1::after {
            content: "";
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 4px;
            background: linear-gradient(90deg, var(--secondary-color), var(--accent-color));
            border-radius: 2px;
        }

        .subtitle {
            font-size: 1.1rem;
            color: var(--secondary-color);
            font-weight: 500;
            margin-top: 20px;
            letter-spacing: 1px;
        }

        .game-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 40px;
            max-width: 1200px;
            width: 100%;
            margin-bottom: 30px;
        }

        .board-container {
            position: relative;
            width: var(--board-size);
            height: var(--board-size);
        }

        .board-frame {
            position: absolute;
            width: calc(var(--board-size) + 40px);
            height: calc(var(--board-size) + 40px);
            background: var(--frame-color);
            top: -20px;
            left: -20px;
            border-radius: 10px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
            z-index: -1;
        }

        #chess-board {
            width: var(--board-size);
            height: var(--board-size);
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 3px solid #2d4059;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
            border-radius: 5px;
        }

        .square {
            width: var(--square-size);
            height: var(--square-size);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .square:hover {
            transform: scale(1.05);
            z-index: 10;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .white {
            background-color: var(--light-square);
        }

        .black {
            background-color: var(--dark-square);
        }

        .piece {
            width: 80%;
            height: 80%;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 1;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 42px;
            filter: drop-shadow(2px 2px 3px rgba(0,0,0,0.3));
        }

        .piece.animated {
            animation: piece-bounce 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes piece-bounce {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            75% { transform: scale(0.9); }
            100% { transform: scale(1); }
        }

        .selected {
            background-color: var(--selected-color) !important;
            box-shadow: inset 0 0 15px rgba(255,255,255,0.5);
        }

        .valid-move {
            position: relative;
        }

        .valid-move::after {
            content: "";
            position: absolute;
            width: 30%;
            height: 30%;
            background-color: var(--valid-move-color);
            border-radius: 50%;
            z-index: 0;
            animation: pulse 1.5s infinite;
            box-shadow: 0 0 10px var(--accent-color);
        }

        .capture-move::after {
            content: "";
            position: absolute;
            width: 90%;
            height: 90%;
            border: 3px solid var(--capture-move-color);
            border-radius: 50%;
            z-index: 0;
            animation: pulse 1.5s infinite;
            box-shadow: 0 0 10px var(--secondary-color);
        }

        .castle-move::after {
            content: "";
            position: absolute;
            width: 70%;
            height: 70%;
            background-color: var(--castle-move-color);
            border-radius: 10%;
            z-index: 0;
            animation: castle-pulse 1.5s infinite;
            box-shadow: 0 0 10px rgba(126, 217, 87, 0.7);
        }

        @keyframes castle-pulse {
            0% { transform: scale(0.9) rotate(0deg); opacity: 0.7; }
            50% { transform: scale(1.1) rotate(45deg); opacity: 1; }
            100% { transform: scale(0.9) rotate(0deg); opacity: 0.7; }
        }

        @keyframes pulse {
            0% { transform: scale(0.9); opacity: 0.7; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(0.9); opacity: 0.7; }
        }

        .game-sidebar {
            display: flex;
            flex-direction: column;
            gap: 25px;
            width: 320px;
        }

        .game-info {
            background-color: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(0,0,0,0.05);
        }

        .game-info::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background: linear-gradient(90deg, var(--secondary-color), var(--accent-color));
        }

        .status-container {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }

        .turn-indicator {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            margin-right: 12px;
            border: 2px solid #333;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }

        .turn-white {
            background-color: white;
            animation: glow-white 2s infinite alternate;
        }

        .turn-black {
            background-color: #333;
            animation: glow-black 2s infinite alternate;
        }

        @keyframes glow-white {
            from { box-shadow: 0 0 5px rgba(255,255,255,0.8); }
            to { box-shadow: 0 0 15px rgba(255,255,255,0.8), 0 0 25px rgba(255,255,255,0.5); }
        }

        @keyframes glow-black {
            from { box-shadow: 0 0 5px rgba(0,0,0,0.8); }
            to { box-shadow: 0 0 15px rgba(0,0,0,0.8), 0 0 25px rgba(0,0,0,0.5); }
        }

        #status {
            font-weight: 600;
            font-size: 1.2rem;
            color: var(--primary-color);
        }

        #message {
            padding: 12px;
            margin-top: 15px;
            border-radius: 8px;
            background-color: var(--accent-color);
            color: white;
            font-weight: 500;
            min-height: 45px;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            text-align: center;
            transform: translateY(10px);
        }

        #message.show {
            opacity: 1;
            transform: translateY(0);
        }

        .captured-pieces {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }

        .captured-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 12px;
            border-radius: 8px;
            background-color: rgba(0,0,0,0.03);
            min-height: 54px;
            align-items: center;
        }

        .captured-piece {
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            transition: all 0.3s ease;
        }

        .captured-piece:hover {
            transform: scale(1.2);
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        button {
            padding: 14px 20px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: 0.5s;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover {
            background-color: var(--secondary-color);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .button-icon {
            font-size: 1.2rem;
        }

        .move-history {
            background-color: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            max-height: 250px;
            overflow-y: auto;
            position: relative;
            border: 1px solid rgba(0,0,0,0.05);
        }

        .move-history::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background: linear-gradient(90deg, var(--accent-color), var(--secondary-color));
        }

        .move-history h3 {
            margin-bottom: 15px;
            color: var(--primary-color);
            text-align: center;
            border-bottom: 1px solid rgba(0,0,0,0.1);
            padding-bottom: 10px;
            font-family: 'Playfair Display', serif;
        }

        .moves-list {
            display: grid;
            grid-template-columns: auto 1fr 1fr;
            gap: 8px;
            align-items: center;
        }

        .move-number {
            font-weight: bold;
            color: var(--secondary-color);
            padding: 4px 8px;
            background-color: rgba(0,0,0,0.03);
            border-radius: 4px;
            text-align: center;
        }

        .move-white, .move-black {
            padding: 6px 10px;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .move-white:hover, .move-black:hover {
            background-color: rgba(72, 191, 227, 0.1);
            transform: translateX(3px);
        }

        .promotion-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        .promotion-content {
            background-color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
            position: relative;
            overflow: hidden;
            max-width: 90%;
            animation: modal-appear 0.5s ease;
        }

        @keyframes modal-appear {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .promotion-content::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background: linear-gradient(90deg, var(--secondary-color), var(--accent-color), var(--secondary-color));
            background-size: 200% 100%;
            animation: gradient-shift 3s linear infinite;
        }

        @keyframes gradient-shift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .promotion-content h3 {
            margin-bottom: 20px;
            color: var(--primary-color);
            font-family: 'Playfair Display', serif;
            font-size: 1.5rem;
        }

        .promotion-options {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }

        .promotion-piece {
            width: 70px;
            height: 70px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 48px;
            cursor: pointer;
            border: 2px solid transparent;
            border-radius: 10px;
            transition: all 0.3s ease;
            background-color: rgba(0,0,0,0.03);
        }

        .promotion-piece:hover {
            border-color: var(--accent-color);
            transform: scale(1.1) translateY(-5px);
            background-color: rgba(72, 191, 227, 0.1);
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }

        .footer {
            margin-top: 20px;
            text-align: center;
            font-size: 0.9rem;
            color: #777;
            width: 100%;
            padding: 15px;
            border-top: 1px solid rgba(0,0,0,0.1);
        }

        .logo {
            font-weight: 700;
            color: var(--primary-color);
            letter-spacing: 1px;
        }

        @media (max-width: 900px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }

            .game-sidebar {
                width: var(--board-size);
                max-width: 100%;
            }

            :root {
                --board-size: min(480px, 90vw);
            }
            
            h1 {
                font-size: 2.5rem;
            }
            
            .subtitle {
                font-size: 1rem;
            }
        }

        /* Animation for captures */
        @keyframes capture {
            0% { transform: scale(1) rotate(0deg); opacity: 1; }
            50% { transform: scale(1.2) rotate(10deg); opacity: 0.5; }
            100% { transform: scale(0) rotate(45deg); opacity: 0; }
        }

        .capturing {
            animation: capture 0.5s forwards;
        }

        /* Animation for check */
        @keyframes check-pulse {
            0% { box-shadow: 0 0 0 0 rgba(235, 87, 87, 0.7); }
            70% { box-shadow: 0 0 0 15px rgba(235, 87, 87, 0); }
            100% { box-shadow: 0 0 0 0 rgba(235, 87, 87, 0); }
        }

        .in-check {
            animation: check-pulse 1.5s infinite;
            background-color: rgba(235, 87, 87, 0.3) !important;
        }

        /* Last move highlight */
        .last-move {
            position: relative;
            overflow: hidden;
        }

        .last-move::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 209, 102, 0.3);
            z-index: 0;
        }
        
        /* Crown decoration */
        .crown {
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 28px;
            color: var(--secondary-color);
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-10px); }
            100% { transform: translateX(-50%) translateY(0); }
        }
        
        /* Captured pieces labels */
        .captured-label {
            font-size: 0.9rem;
            color: var(--primary-color);
            margin-bottom: 5px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .captured-label::before {
            content: '•';
            color: var(--secondary-color);
            font-size: 1.2rem;
        }
        
        /* Empty state styling */
        .empty-state {
            text-align: center;
            padding: 10px;
            color: #777;
            font-style: italic;
            animation: fade-in 0.5s ease;
        }

        @keyframes fade-in {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Piece hover effect */
        .piece:hover {
            filter: drop-shadow(0 0 8px var(--accent-color));
        }

        /* Scrollbar styling */
        .move-history::-webkit-scrollbar {
            width: 8px;
        }

        .move-history::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.05);
            border-radius: 10px;
        }

        .move-history::-webkit-scrollbar-thumb {
            background: var(--accent-color);
            border-radius: 10px;
        }

        .move-history::-webkit-scrollbar-thumb:hover {
            background: var(--secondary-color);
        }

        /* Castling animation */
        @keyframes castle-rook {
            0% { transform: translateX(0); }
            50% { transform: translateY(-10px); }
            100% { transform: translateX(var(--castle-distance)); }
        }

        .castling-rook {
            animation: castle-rook 0.8s forwards;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Royal Chess<span class="crown">♔</span></h1>
        <p class="subtitle">An elegant chess experience for all generations</p>
    </div>
    
    <div class="game-container">
        <div class="board-container">
            <div class="board-frame"></div>
            <div id="chess-board"></div>
        </div>
        
        <div class="game-sidebar">
            <div class="game-info">
                <div class="status-container">
                    <div class="turn-indicator turn-white" id="turn-indicator"></div>
                    <p id="status">White's turn</p>
                </div>
                <div id="message"></div>
                
                <div class="captured-pieces">
                    <div class="captured-label">Captured by White:</div>
                    <div class="captured-row" id="captured-black"></div>
                    <div class="captured-label">Captured by Black:</div>
                    <div class="captured-row" id="captured-white"></div>
                </div>
            </div>
            
            <div class="move-history">
                <h3>Move History</h3>
                <div class="moves-list" id="moves-list"></div>
            </div>
            
            <div class="controls">
                <button id="reset-btn">
                    <span class="button-icon">↺</span> New Game
                </button>
                <button id="undo-btn">
                    <span class="button-icon">↩</span> Undo Move
                </button>
                <button id="flip-btn">
                    <span class="button-icon">⇅</span> Flip Board
                </button>
            </div>
        </div>
    </div>
    
    <div class="promotion-modal" id="promotion-modal">
        <div class="promotion-content">
            <h3>Choose a piece for promotion</h3>
            <div class="promotion-options" id="promotion-options"></div>
        </div>
    </div>

    <footer class="footer">
        <p>© 2023 <span class="logo">SRUSTI</span>. All Rights Reserved.</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // DOM elements
            const chessBoard = document.getElementById('chess-board');
            const statusElement = document.getElementById('status');
            const messageElement = document.getElementById('message');
            const resetButton = document.getElementById('reset-btn');
            const undoButton = document.getElementById('undo-btn');
            const flipButton = document.getElementById('flip-btn');
            const turnIndicator = document.getElementById('turn-indicator');
            const capturedWhite = document.getElementById('captured-white');
            const capturedBlack = document.getElementById('captured-black');
            const movesList = document.getElementById('moves-list');
            const promotionModal = document.getElementById('promotion-modal');
            const promotionOptions = document.getElementById('promotion-options');
            
            // Game state
            const game = {
                board: [],
                currentPlayer: 'white',
                selectedPiece: null,
                validMoves: [],
                capturedPieces: {
                    white: [],
                    black: []
                },
                moveHistory: [],
                kings: {
                    white: { row: 7, col: 4 },
                    black: { row: 0, col: 4 }
                },
                castlingRights: {
                    white: { kingSide: true, queenSide: true },
                    black: { kingSide: true, queenSide: true }
                },
                inCheck: null,
                lastMove: null,
                boardOrientation: 'white', // 'white' or 'black'
                waitingForPromotion: null
            };
            
            // Piece symbols mapping
            const pieceSymbols = {
                'white': {
                    'pawn': '♙',
                    'rook': '♖',
                    'knight': '♘',
                    'bishop': '♗',
                    'queen': '♕',
                    'king': '♔'
                },
                'black': {
                    'pawn': '♟',
                    'rook': '♜',
                    'knight': '♞',
                    'bishop': '♝',
                    'queen': '♛',
                    'king': '♚'
                }
            };
            
            // Initialize the board
            function initializeBoard() {
                const board = [];
                
                // Create empty board
                for (let i = 0; i < 8; i++) {
                    const row = [];
                    for (let j = 0; j < 8; j++) {
                        row.push(null);
                    }
                    board.push(row);
                }
                
                // Set up pawns
                for (let col = 0; col < 8; col++) {
                    board[1][col] = { type: 'pawn', color: 'black', hasMoved: false };
                    board[6][col] = { type: 'pawn', color: 'white', hasMoved: false };
                }
                
                // Set up rooks
                board[0][0] = { type: 'rook', color: 'black', hasMoved: false };
                board[0][7] = { type: 'rook', color: 'black', hasMoved: false };
                board[7][0] = { type: 'rook', color: 'white', hasMoved: false };
                board[7][7] = { type: 'rook', color: 'white', hasMoved: false };
                
                // Set up knights
                board[0][1] = { type: 'knight', color: 'black' };
                board[0][6] = { type: 'knight', color: 'black' };
                board[7][1] = { type: 'knight', color: 'white' };
                board[7][6] = { type: 'knight', color: 'white' };
                
                // Set up bishops
                board[0][2] = { type: 'bishop', color: 'black' };
                board[0][5] = { type: 'bishop', color: 'black' };
                board[7][2] = { type: 'bishop', color: 'white' };
                board[7][5] = { type: 'bishop', color: 'white' };
                
                // Set up queens
                board[0][3] = { type: 'queen', color: 'black' };
                board[7][3] = { type: 'queen', color: 'white' };
                
                // Set up kings
                board[0][4] = { type: 'king', color: 'black', hasMoved: false };
                board[7][4] = { type: 'king', color: 'white', hasMoved: false };
                
                return board;
            }

            // Render the chess board
            function renderBoard() {
                chessBoard.innerHTML = '';
                
                // Determine the rendering order based on board orientation
                const rowOrder = game.boardOrientation === 'white' ? 
                    [0, 1, 2, 3, 4, 5, 6, 7] : 
                    [7, 6, 5, 4, 3, 2, 1, 0];
                
                const colOrder = game.boardOrientation === 'white' ? 
                    [0, 1, 2, 3, 4, 5, 6, 7] : 
                    [7, 6, 5, 4, 3, 2, 1, 0];
                
                for (let i = 0; i < 8; i++) {
                    const row = rowOrder[i];
                    
                    for (let j = 0; j < 8; j++) {
                        const col = colOrder[j];
                        
                        const square = document.createElement('div');
                        square.className = `square ${(row + col) % 2 === 0 ? 'white' : 'black'}`;
                        square.dataset.row = row;
                        square.dataset.col = col;
                        
                        // Check if this square was part of the last move
                        if (game.lastMove && 
                            ((row === game.lastMove.fromRow && col === game.lastMove.fromCol) || 
                             (row === game.lastMove.toRow && col === game.lastMove.toCol))) {
                            square.classList.add('last-move');
                        }
                        
                        // Check if king is in check
                        if (game.inCheck && 
                            game.kings[game.inCheck].row === row && 
                            game.kings[game.inCheck].col === col) {
                            square.classList.add('in-check');
                        }
                        
                        const piece = game.board[row][col];
                        if (piece) {
                            const pieceElement = document.createElement('div');
                            pieceElement.className = 'piece';
                            pieceElement.textContent = pieceSymbols[piece.color][piece.type];
                            pieceElement.style.color = piece.color;
                            square.appendChild(pieceElement);
                        }
                        
                        // Highlight selected piece
                        if (game.selectedPiece && 
                            game.selectedPiece.row === row && 
                            game.selectedPiece.col === col) {
                            square.classList.add('selected');
                        }
                        
                        // Highlight valid moves
                        const validMove = game.validMoves.find(move => move.row === row && move.col === col);
                        if (validMove) {
                            if (validMove.castle) {
                                square.classList.add('castle-move');
                            } else if (validMove.capture) {
                                square.classList.add('capture-move');
                            } else {
                                square.classList.add('valid-move');
                            }
                        }
                        
                        square.addEventListener('click', () => handleSquareClick(row, col));
                        chessBoard.appendChild(square);
                    }
                }
                
                // Update game info
                updateGameInfo();
                
                // Update captured pieces
                renderCapturedPieces();
                
                // Update move history
                renderMoveHistory();
            }

            // Handle square click
            function handleSquareClick(row, col) {
                // If waiting for promotion, ignore clicks
                if (game.waitingForPromotion) return;
                
                const piece = game.board[row][col];
                
                // If no piece is selected and the clicked square has a piece of the current player's color
                if (!game.selectedPiece && piece && piece.color === game.currentPlayer) {
                    selectPiece(row, col);
                    return;
                }
                
                // If a piece is already selected
                if (game.selectedPiece) {
                    // If clicking on another piece of the same color, select that piece instead
                    if (piece && piece.color === game.currentPlayer) {
                        selectPiece(row, col);
                        return;
                    }
                    
                    // Check if the clicked square is a valid move
                    const validMove = game.validMoves.find(move => move.row === row && move.col === col);
                    if (validMove) {
                        if (validMove.castle) {
                            performCastling(game.selectedPiece.row, game.selectedPiece.col, row, col, validMove.castleSide);
                        } else {
                            movePiece(game.selectedPiece.row, game.selectedPiece.col, row, col);
                        }
                    } else {
                        // Deselect if clicking on an invalid square
                        game.selectedPiece = null;
                        game.validMoves = [];
                        renderBoard();
                    }
                }
            }

            // Select a piece and show valid moves
            function selectPiece(row, col) {
                const piece = game.board[row][col];
                if (!piece || piece.color !== game.currentPlayer) return;
                
                game.selectedPiece = { row, col, type: piece.type, color: piece.color };
                game.validMoves = getValidMoves(row, col);
                
                renderBoard();
                
                // Add animation to the selected piece
                const squares = document.querySelectorAll('.square');
                squares.forEach(square => {
                    if (parseInt(square.dataset.row) === row && parseInt(square.dataset.col) === col) {
                        const pieceElement = square.querySelector('.piece');
                        if (pieceElement) {
                            pieceElement.classList.add('animated');
                            setTimeout(() => {
                                pieceElement.classList.remove('animated');
                            }, 600);
                        }
                    }
                });
            }

            // Move a piece
            function movePiece(fromRow, fromCol, toRow, toCol) {
                const piece = game.board[fromRow][fromCol];
                const targetPiece = game.board[toRow][toCol];
                
                // Store the move for history
                const move = {
                    piece: piece.type,
                    color: piece.color,
                    fromRow,
                    fromCol,
                    toRow,
                    toCol,
                    capture: !!targetPiece,
                    capturedPiece: targetPiece ? targetPiece.type : null
                };
                
                // Check for pawn promotion
                if (piece.type === 'pawn' && ((piece.color === 'white' && toRow === 0) || (piece.color === 'black' && toRow === 7))) {
                    game.waitingForPromotion = { fromRow, fromCol, toRow, toCol };
                    showPromotionOptions(piece.color, toRow, toCol);
                    return;
                }
                
                // Capture animation
                if (targetPiece) {
                    const squares = document.querySelectorAll('.square');
                    squares.forEach(square => {
                        if (parseInt(square.dataset.row) === toRow && parseInt(square.dataset.col) === toCol) {
                            const pieceElement = square.querySelector('.piece');
                            if (pieceElement) {
                                pieceElement.classList.add('capturing');
                                
                                // Add to captured pieces
                                game.capturedPieces[targetPiece.color].push(targetPiece.type);
                            }
                        }
                    });
                    
                    // Wait for animation to complete
                    setTimeout(() => {
                        completeMove(fromRow, fromCol, toRow, toCol, piece.type);
                    }, 500);
                } else {
                    completeMove(fromRow, fromCol, toRow, toCol, piece.type);
                }
                
                // Add to move history
                game.moveHistory.push(move);
            }

            // Perform castling move
            function performCastling(fromRow, fromCol, toRow, toCol, castleSide) {
                // Move the king
                const king = game.board[fromRow][fromCol];
                game.board[toRow][toCol] = king;
                game.board[fromRow][fromCol] = null;
                
                // Update king position
                game.kings[king.color].row = toRow;
                game.kings[king.color].col = toCol;
                
                // Move the rook
                let rookFromCol, rookToCol;
                if (castleSide === 'king') {
                    rookFromCol = 7;
                    rookToCol = toCol - 1; // Place rook to the left of king
                } else { // queen side
                    rookFromCol = 0;
                    rookToCol = toCol + 1; // Place rook to the right of king
                }
                
                const rook = game.board[fromRow][rookFromCol];
                game.board[fromRow][rookToCol] = rook;
                game.board[fromRow][rookFromCol] = null;
                
                // Mark pieces as moved
                king.hasMoved = true;
                rook.hasMoved = true;
                
                // Update castling rights
                game.castlingRights[king.color].kingSide = false;
                game.castlingRights[king.color].queenSide = false;
                
                // Store the move for history
                const move = {
                    piece: 'king',
                    color: king.color,
                    fromRow,
                    fromCol,
                    toRow,
                    toCol,
                    castle: true,
                    castleSide
                };
                
                game.moveHistory.push(move);
                
                // Store last move for highlighting
                game.lastMove = {
                    fromRow,
                    fromCol,
                    toRow,
                    toCol
                };
                
                // Reset selection
                game.selectedPiece = null;
                game.validMoves = [];
                
                // Switch player
                game.currentPlayer = game.currentPlayer === 'white' ? 'black' : 'white';
                
                // Check if the new current player is in check
                game.inCheck = isKingInCheck(game.currentPlayer) ? game.currentPlayer : null;
                
                // Check for checkmate or stalemate
                if (isCheckmate()) {
                    showMessage(`Checkmate! ${game.currentPlayer === 'white' ? 'Black' : 'White'} wins!`);
                } else if (isStalemate()) {
                    showMessage("Stalemate! The game is a draw.");
                } else if (game.inCheck) {
                    showMessage(`${game.currentPlayer.charAt(0).toUpperCase() + game.currentPlayer.slice(1)} is in check!`);
                } else {
                    hideMessage();
                }
                
                renderBoard();
            }

            // Complete the move after any animations
            function completeMove(fromRow, fromCol, toRow, toCol, pieceType) {
                const piece = game.board[fromRow][fromCol];
                
                // Update the board
                game.board[toRow][toCol] = piece;
                game.board[fromRow][fromCol] = null;
                
                // Mark piece as moved (for pawns, kings, rooks)
                if (piece.type === 'king' || piece.type === 'rook' || piece.type === 'pawn') {
                    piece.hasMoved = true;
                }
                
                // Update castling rights if king or rook moves
                if (piece.type === 'king') {
                    game.castlingRights[piece.color].kingSide = false;
                    game.castlingRights[piece.color].queenSide = false;
                    
                    // Update king position
                    game.kings[piece.color].row = toRow;
                    game.kings[piece.color].col = toCol;
                } else if (piece.type === 'rook') {
                    // Check if it's a corner rook
                    if (fromRow === 0 && fromCol === 0) { // Black queen-side rook
                        game.castlingRights.black.queenSide = false;
                    } else if (fromRow === 0 && fromCol === 7) { // Black king-side rook
                        game.castlingRights.black.kingSide = false;
                    } else if (fromRow === 7 && fromCol === 0) { // White queen-side rook
                        game.castlingRights.white.queenSide = false;
                    } else if (fromRow === 7 && fromCol === 7) { // White king-side rook
                        game.castlingRights.white.kingSide = false;
                    }
                }
                
                // Store last move for highlighting
                game.lastMove = {
                    fromRow,
                    fromCol,
                    toRow,
                    toCol
                };
                
                // Reset selection
                game.selectedPiece = null;
                game.validMoves = [];
                
                // Switch player
                game.currentPlayer = game.currentPlayer === 'white' ? 'black' : 'white';
                
                // Check if the new current player is in check
                game.inCheck = isKingInCheck(game.currentPlayer) ? game.currentPlayer : null;
                
                // Check for checkmate or stalemate
                if (isCheckmate()) {
                    showMessage(`Checkmate! ${game.currentPlayer === 'white' ? 'Black' : 'White'} wins!`);
                } else if (isStalemate()) {
                    showMessage("Stalemate! The game is a draw.");
                } else if (game.inCheck) {
                    showMessage(`${game.currentPlayer.charAt(0).toUpperCase() + game.currentPlayer.slice(1)} is in check!`);
                } else {
                    hideMessage();
                }
                
                renderBoard();
            }

            // Handle pawn promotion
            function showPromotionOptions(color, row, col) {
                promotionOptions.innerHTML = '';
                
                const pieceTypes = ['queen', 'rook', 'bishop', 'knight'];
                
                pieceTypes.forEach(type => {
                    const pieceElement = document.createElement('div');
                    pieceElement.className = 'promotion-piece';
                    pieceElement.textContent = pieceSymbols[color][type];
                    pieceElement.style.color = color;
                    pieceElement.addEventListener('click', () => {
                        promotePawn(type);
                        promotionModal.style.display = 'none';
                    });
                    
                    promotionOptions.appendChild(pieceElement);
                });
                
                promotionModal.style.display = 'flex';
            }

            // Complete pawn promotion
            function promotePawn(pieceType) {
                const { fromRow, fromCol, toRow, toCol } = game.waitingForPromotion;
                const currentColor = game.currentPlayer;
                const targetPiece = game.board[toRow][toCol];
                
                // Check if there was a capture
                const isCapture = targetPiece !== null;
                if (isCapture && targetPiece) {
                    // Add to captured pieces
                    game.capturedPieces[targetPiece.color].push(targetPiece.type);
                }
                
                // Update the piece type
                game.board[toRow][toCol] = {
                    type: pieceType,
                    color: currentColor,
                    hasMoved: true
                };
                
                game.board[fromRow][fromCol] = null;
                
                // Add to move history with promotion info
                const move = {
                    piece: 'pawn',
                    color: currentColor,
                    fromRow,
                    fromCol,
                    toRow,
                    toCol,
                    promotion: pieceType,
                    capture: isCapture,
                    capturedPiece: isCapture && targetPiece ? targetPiece.type : null
                };
                
                game.moveHistory.push(move);
                
                // Reset waiting for promotion
                game.waitingForPromotion = null;
                
                // Store last move for highlighting
                game.lastMove = {
                    fromRow,
                    fromCol,
                    toRow,
                    toCol
                };
                
                // Switch player
                game.currentPlayer = game.currentPlayer === 'white' ? 'black' : 'white';
                
                // Check if the new current player is in check
                game.inCheck = isKingInCheck(game.currentPlayer) ? game.currentPlayer : null;
                
                // Check for checkmate or stalemate
                if (isCheckmate()) {
                    showMessage(`Checkmate! ${game.currentPlayer === 'white' ? 'Black' : 'White'} wins!`);
                } else if (isStalemate()) {
                    showMessage("Stalemate! The game is a draw.");
                } else if (game.inCheck) {
                    showMessage(`${game.currentPlayer.charAt(0).toUpperCase() + game.currentPlayer.slice(1)} is in check!`);
                }
                
                renderBoard();
            }

            // Get valid moves for a piece
            function getValidMoves(row, col) {
                const piece = game.board[row][col];
                if (!piece) return [];
                
                let moves = [];
                
                switch (piece.type) {
                    case 'pawn':
                        moves = getPawnMoves(row, col, piece.color);
                        break;
                    case 'rook':
                        moves = getRookMoves(row, col, piece.color);
                        break;
                    case 'knight':
                        moves = getKnightMoves(row, col, piece.color);
                        break;
                    case 'bishop':
                        moves = getBishopMoves(row, col, piece.color);
                        break;
                    case 'queen':
                        moves = getQueenMoves(row, col, piece.color);
                        break;
                    case 'king':
                        moves = getKingMoves(row, col, piece.color);
                        break;
                }
                
                // Filter out moves that would put or leave the king in check
                return moves.filter(move => {
                    // Skip this check for castling moves - they're checked separately
                    if (move.castle) return true;
                    
                    // Temporarily make the move
                    const originalTarget = game.board[move.row][move.col];
                    game.board[move.row][move.col] = piece;
                    game.board[row][col] = null;
                    
                    // Update king position temporarily if moving the king
                    const originalKingPos = { ...game.kings[piece.color] };
                    if (piece.type === 'king') {
                        game.kings[piece.color].row = move.row;
                        game.kings[piece.color].col = move.col;
                    }
                    
                    // Check if the king would be in check
                    const inCheck = isKingInCheck(piece.color);
                    
                    // Undo the move
                    game.board[row][col] = piece;
                    game.board[move.row][move.col] = originalTarget;
                    
                    // Restore king position if it was moved
                    if (piece.type === 'king') {
                        game.kings[piece.color] = originalKingPos;
                    }
                    
                    return !inCheck;
                });
            }

            // Get valid moves for a pawn
            function getPawnMoves(row, col, color) {
                const moves = [];
                const direction = color === 'white' ? -1 : 1;
                const startRow = color === 'white' ? 6 : 1;
                
                // Move forward one square
                if (isInBounds(row + direction, col) && !game.board[row + direction][col]) {
                    moves.push({ row: row + direction, col: col });
                    
                    // Move forward two squares from starting position
                    if (row === startRow && !game.board[row + 2 * direction][col]) {
                        moves.push({ row: row + 2 * direction, col: col });
                    }
                }
                
                // Capture diagonally
                const captureMoves = [
                    { row: row + direction, col: col - 1 },
                    { row: row + direction, col: col + 1 }
                ];
                
                captureMoves.forEach(move => {
                    if (isInBounds(move.row, move.col) && 
                        game.board[move.row][move.col] && 
                        game.board[move.row][move.col].color !== color) {
                        moves.push({ ...move, capture: true });
                    }
                });
                
                return moves;
            }

            // Get valid moves for a rook
            function getRookMoves(row, col, color) {
                return getStraightMoves(row, col, color);
            }

            // Get valid moves for a knight
            function getKnightMoves(row, col, color) {
                const moves = [];
                const knightMoves = [
                    { row: row - 2, col: col - 1 },
                    { row: row - 2, col: col + 1 },
                    { row: row - 1, col: col - 2 },
                    { row: row - 1, col: col + 2 },
                    { row: row + 1, col: col - 2 },
                    { row: row + 1, col: col + 2 },
                    { row: row + 2, col: col - 1 },
                    { row: row + 2, col: col + 1 }
                ];
                
                knightMoves.forEach(move => {
                    if (isInBounds(move.row, move.col)) {
                        const targetPiece = game.board[move.row][move.col];
                        if (!targetPiece || targetPiece.color !== color) {
                            moves.push({ 
                                row: move.row, 
                                col: move.col,
                                capture: targetPiece !== null
                            });
                        }
                    }
                });
                
                return moves;
            }

            // Get valid moves for a bishop
            function getBishopMoves(row, col, color) {
                return getDiagonalMoves(row, col, color);
            }

            // Get valid moves for a queen
            function getQueenMoves(row, col, color) {
                return [...getStraightMoves(row, col, color), ...getDiagonalMoves(row, col, color)];
            }

            // Get valid moves for a king
            function getKingMoves(row, col, color) {
                const moves = [];
                const kingMoves = [
                    { row: row - 1, col: col - 1 },
                    { row: row - 1, col: col },
                    { row: row - 1, col: col + 1 },
                    { row: row, col: col - 1 },
                    { row: row, col: col + 1 },
                    { row: row + 1, col: col - 1 },
                    { row: row + 1, col: col },
                    { row: row + 1, col: col + 1 }
                ];
                
                kingMoves.forEach(move => {
                    if (isInBounds(move.row, move.col)) {
                        const targetPiece = game.board[move.row][move.col];
                        if (!targetPiece || targetPiece.color !== color) {
                            moves.push({ 
                                row: move.row, 
                                col: move.col,
                                capture: targetPiece !== null
                            });
                        }
                    }
                });
                
                // Check for castling
                const king = game.board[row][col];
                if (!king.hasMoved && !isKingInCheck(color)) {
                    // King-side castling
                    if (game.castlingRights[color].kingSide) {
                        const rookCol = 7;
                        const rook = game.board[row][rookCol];
                        
                        if (rook && rook.type === 'rook' && !rook.hasMoved) {
                            // Check if squares between king and rook are empty
                            if (!game.board[row][col + 1] && !game.board[row][col + 2]) {
                                // Check if king would pass through check
                                let canCastle = true;
                                
                                // Temporarily move king one square towards rook and check for check
                                game.board[row][col + 1] = king;
                                game.board[row][col] = null;
                                
                                // Update king position temporarily
                                const originalKingPos = { ...game.kings[color] };
                                game.kings[color].col = col + 1;
                                
                                if (isKingInCheck(color)) {
                                    canCastle = false;
                                }
                                
                                // Restore king position
                                game.board[row][col] = king;
                                game.board[row][col + 1] = null;
                                game.kings[color] = originalKingPos;
                                
                                if (canCastle) {
                                    moves.push({
                                        row: row,
                                        col: col + 2,
                                        castle: true,
                                        castleSide: 'king'
                                    });
                                }
                            }
                        }
                    }
                    
                    // Queen-side castling
                    if (game.castlingRights[color].queenSide) {
                        const rookCol = 0;
                        const rook = game.board[row][rookCol];
                        
                        if (rook && rook.type === 'rook' && !rook.hasMoved) {
                            // Check if squares between king and rook are empty
                            if (!game.board[row][col - 1] && !game.board[row][col - 2] && !game.board[row][col - 3]) {
                                // Check if king would pass through check
                                let canCastle = true;
                                
                                // Temporarily move king one square towards rook and check for check
                                game.board[row][col - 1] = king;
                                game.board[row][col] = null;
                                
                                // Update king position temporarily
                                const originalKingPos = { ...game.kings[color] };
                                game.kings[color].col = col - 1;
                                
                                if (isKingInCheck(color)) {
                                    canCastle = false;
                                }
                                
                                // Restore king position
                                game.board[row][col] = king;
                                game.board[row][col - 1] = null;
                                game.kings[color] = originalKingPos;
                                
                                if (canCastle) {
                                    moves.push({
                                        row: row,
                                        col: col - 2,
                                        castle: true,
                                        castleSide: 'queen'
                                    });
                                }
                            }
                        }
                    }
                }
                
                return moves;
            }

            // Get straight line moves (for rook and queen)
            function getStraightMoves(row, col, color) {
                const moves = [];
                const directions = [
                    { row: -1, col: 0 }, // up
                    { row: 1, col: 0 },  // down
                    { row: 0, col: -1 }, // left
                    { row: 0, col: 1 }   // right
                ];
                
                directions.forEach(dir => {
                    let r = row + dir.row;
                    let c = col + dir.col;
                    
                    while (isInBounds(r, c)) {
                        const targetPiece = game.board[r][c];
                        
                        if (!targetPiece) {
                            moves.push({ row: r, col: c });
                        } else {
                            if (targetPiece.color !== color) {
                                moves.push({ row: r, col: c, capture: true });
                            }
                            break;
                        }
                        
                        r += dir.row;
                        c += dir.col;
                    }
                });
                
                return moves;
            }

            // Get diagonal moves (for bishop and queen)
            function getDiagonalMoves(row, col, color) {
                const moves = [];
                const directions = [
                    { row: -1, col: -1 }, // up-left
                    { row: -1, col: 1 },  // up-right
                    { row: 1, col: -1 },  // down-left
                    { row: 1, col: 1 }    // down-right
                ];
                
                directions.forEach(dir => {
                    let r = row + dir.row;
                    let c = col + dir.col;
                    
                    while (isInBounds(r, c)) {
                        const targetPiece = game.board[r][c];
                        
                        if (!targetPiece) {
                            moves.push({ row: r, col: c });
                        } else {
                            if (targetPiece.color !== color) {
                                moves.push({ row: r, col: c, capture: true });
                            }
                            break;
                        }
                        
                        r += dir.row;
                        c += dir.col;
                    }
                });
                
                return moves;
            }

            // Check if a position is within the board boundaries
            function isInBounds(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }

            // Check if the king is in check
            function isKingInCheck(color) {
                const kingPos = game.kings[color];
                const opponentColor = color === 'white' ? 'black' : 'white';
                
                // Check all opponent pieces to see if they can capture the king
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = game.board[row][col];
                        if (piece && piece.color === opponentColor) {
                            let moves;
                            
                            // Get all possible moves for this piece
                            switch (piece.type) {
                                case 'pawn':
                                    // For pawns, we only need to check capture moves
                                    const direction = piece.color === 'white' ? -1 : 1;
                                    const captureMoves = [
                                        { row: row + direction, col: col - 1 },
                                        { row: row + direction, col: col + 1 }
                                    ];
                                    
                                    for (const move of captureMoves) {
                                        if (isInBounds(move.row, move.col) && 
                                            move.row === kingPos.row && 
                                            move.col === kingPos.col) {
                                            return true;
                                        }
                                    }
                                    continue;
                                case 'rook':
                                    moves = getStraightMoves(row, col, piece.color);
                                    break;
                                case 'knight':
                                    moves = getKnightMoves(row, col, piece.color);
                                    break;
                                case 'bishop':
                                    moves = getDiagonalMoves(row, col, piece.color);
                                    break;
                                case 'queen':
                                    moves = [...getStraightMoves(row, col, piece.color), ...getDiagonalMoves(row, col, piece.color)];
                                    break;
                                case 'king':
                                    // For kings, we need to check one square in each direction
                                    const kingMoves = [
                                        { row: row - 1, col: col - 1 },
                                        { row: row - 1, col: col },
                                        { row: row - 1, col: col + 1 },
                                        { row: row, col: col - 1 },
                                        { row: row, col: col + 1 },
                                        { row: row + 1, col: col - 1 },
                                        { row: row + 1, col: col },
                                        { row: row + 1, col: col + 1 }
                                    ];
                                    
                                    for (const move of kingMoves) {
                                        if (isInBounds(move.row, move.col) && 
                                            move.row === kingPos.row && 
                                            move.col === kingPos.col) {
                                            return true;
                                        }
                                    }
                                    continue;
                            }
                            
                            // Check if any of the moves can capture the king
                            for (const move of moves) {
                                if (move.row === kingPos.row && move.col === kingPos.col) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                
                return false;
            }

            // Check for checkmate
            function isCheckmate() {
                if (!game.inCheck) return false;
                
                // Check if any piece can make a move that gets out of check
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = game.board[row][col];
                        if (piece && piece.color === game.currentPlayer) {
                            const moves = getValidMoves(row, col);
                            if (moves.length > 0) {
                                return false;
                            }
                        }
                    }
                }
                
                return true;
            }

            // Check for stalemate
            function isStalemate() {
                if (game.inCheck) return false;
                
                // Check if the current player has any legal moves
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = game.board[row][col];
                        if (piece && piece.color === game.currentPlayer) {
                            const moves = getValidMoves(row, col);
                            if (moves.length > 0) {
                                return false;
                            }
                        }
                    }
                }
                
                return true;
            }

            // Update game info display
            function updateGameInfo() {
                statusElement.textContent = `${game.currentPlayer.charAt(0).toUpperCase() + game.currentPlayer.slice(1)}'s turn`;
                turnIndicator.className = `turn-indicator turn-${game.currentPlayer}`;
            }

            // Show message
            function showMessage(text) {
                messageElement.textContent = text;
                messageElement.classList.add('show');
            }

            // Hide message
            function hideMessage() {
                messageElement.classList.remove('show');
            }

            // Render captured pieces
            function renderCapturedPieces() {
                capturedWhite.innerHTML = '';
                capturedBlack.innerHTML = '';
                
                if (game.capturedPieces.white.length === 0) {
                    const emptyState = document.createElement('div');
                    emptyState.className = 'empty-state';
                    emptyState.textContent = 'No pieces captured yet';
                    capturedWhite.appendChild(emptyState);
                } else {
                    game.capturedPieces.white.forEach(pieceType => {
                        const pieceElement = document.createElement('div');
                        pieceElement.className = 'captured-piece';
                        pieceElement.textContent = pieceSymbols['white'][pieceType];
                        pieceElement.style.color = 'white';
                        pieceElement.style.textShadow = '1px 1px 1px rgba(0,0,0,0.3)';
                        capturedWhite.appendChild(pieceElement);
                    });
                }
                
                if (game.capturedPieces.black.length === 0) {
                    const emptyState = document.createElement('div');
                    emptyState.className = 'empty-state';
                    emptyState.textContent = 'No pieces captured yet';
                    capturedBlack.appendChild(emptyState);
                } else {
                    game.capturedPieces.black.forEach(pieceType => {
                        const pieceElement = document.createElement('div');
                        pieceElement.className = 'captured-piece';
                        pieceElement.textContent = pieceSymbols['black'][pieceType];
                        pieceElement.style.color = 'black';
                        capturedBlack.appendChild(pieceElement);
                    });
                }
            }

            // Render move history
            function renderMoveHistory() {
                movesList.innerHTML = '';
                
                if (game.moveHistory.length === 0) {
                    const emptyMessage = document.createElement('div');
                    emptyMessage.className = 'empty-state';
                    emptyMessage.textContent = 'No moves yet';
                    movesList.appendChild(emptyMessage);
                    return;
                }
                
                for (let i = 0; i < game.moveHistory.length; i += 2) {
                    const moveNumber = document.createElement('div');
                    moveNumber.className = 'move-number';
                    moveNumber.textContent = `${Math.floor(i / 2) + 1}.`;
                    
                    const whiteMove = document.createElement('div');
                    whiteMove.className = 'move-white';
                    whiteMove.textContent = formatMove(game.moveHistory[i]);
                    
                    movesList.appendChild(moveNumber);
                    movesList.appendChild(whiteMove);
                    
                    if (i + 1 < game.moveHistory.length) {
                        const blackMove = document.createElement('div');
                        blackMove.className = 'move-black';
                        blackMove.textContent = formatMove(game.moveHistory[i + 1]);
                        movesList.appendChild(blackMove);
                    } else {
                        const emptyCell = document.createElement('div');
                        movesList.appendChild(emptyCell);
                    }
                }
                
                // Scroll to bottom
                movesList.scrollTop = movesList.scrollHeight;
            }

            // Format move for display
            function formatMove(move) {
                if (!move) return '';
                
                const pieceSymbols = {
                    'king': 'K',
                    'queen': 'Q',
                    'rook': 'R',
                    'bishop': 'B',
                    'knight': 'N',
                    'pawn': ''
                };
                
                // Special case for castling
                if (move.castle) {
                    return move.castleSide === 'king' ? 'O-O' : 'O-O-O';
                }
                
                let notation = '';
                
                // Add piece symbol
                notation += pieceSymbols[move.piece];
                
                // Add capture symbol
                if (move.capture) {
                    if (move.piece === 'pawn') {
                        notation += 'x';
                    } else {
                        notation += 'x';
                    }
                }
                
                // Add promotion
                if (move.promotion) {
                    notation += '=' + pieceSymbols[move.promotion];
                }
                
                return notation;
            }

            // Reset the game
            function resetGame() {
                game.board = initializeBoard();
                game.currentPlayer = 'white';
                game.selectedPiece = null;
                game.validMoves = [];
                game.capturedPieces = {
                    white: [],
                    black: []
                };
                game.moveHistory = [];
                game.kings = {
                    white: { row: 7, col: 4 },
                    black: { row: 0, col: 4 }
                };
                game.castlingRights = {
                    white: { kingSide: true, queenSide: true },
                    black: { kingSide: true, queenSide: true }
                };
                game.inCheck = null;
                game.lastMove = null;
                game.waitingForPromotion = null;
                
                renderBoard();
                hideMessage();
                
                // Show a welcome message
                showMessage("Game started! White to move.");
                setTimeout(hideMessage, 3000);
            }

            // Undo the last move
            function undoMove() {
                if (game.moveHistory.length === 0) {
                    showMessage("No moves to undo!");
                    setTimeout(hideMessage, 2000);
                    return;
                }
                
                const lastMove = game.moveHistory.pop();
                
                // Handle castling undo
                if (lastMove.castle) {
                    // Restore king
                    game.board[lastMove.fromRow][lastMove.fromCol] = {
                        type: 'king',
                        color: lastMove.color,
                        hasMoved: false
                    };
                    game.board[lastMove.toRow][lastMove.toCol] = null;
                    
                    // Restore rook
                    const rookRow = lastMove.fromRow;
                    let rookFromCol, rookToCol;
                    
                    if (lastMove.castleSide === 'king') {
                        rookFromCol = 7;
                        rookToCol = lastMove.toCol - 1;
                    } else { // queen side
                        rookFromCol = 0;
                        rookToCol = lastMove.toCol + 1;
                    }
                    
                    game.board[rookRow][rookFromCol] = {
                        type: 'rook',
                        color: lastMove.color,
                        hasMoved: false
                    };
                    game.board[rookRow][rookToCol] = null;
                    
                    // Restore castling rights
                    game.castlingRights[lastMove.color].kingSide = true;
                    game.castlingRights[lastMove.color].queenSide = true;
                    
                    // Update king position
                    game.kings[lastMove.color].row = lastMove.fromRow;
                    game.kings[lastMove.color].col = lastMove.fromCol;
                } else {
                    // Regular move undo
                    
                    // Handle promotion
                    if (lastMove.promotion) {
                        // Restore pawn
                        game.board[lastMove.fromRow][lastMove.fromCol] = {
                            type: 'pawn',
                            color: lastMove.color,
                            hasMoved: true
                        };
                    } else {
                        // Restore the piece to its original position
                        game.board[lastMove.fromRow][lastMove.fromCol] = {
                            type: lastMove.piece,
                            color: lastMove.color,
                            hasMoved: lastMove.piece === 'king' || lastMove.piece === 'rook' || lastMove.piece === 'pawn'
                        };
                    }
                    
                    // If it was a capture, restore the captured piece
                    if (lastMove.capture) {
                        game.board[lastMove.toRow][lastMove.toCol] = {
                            type: lastMove.capturedPiece,
                            color: lastMove.color === 'white' ? 'black' : 'white',
                            hasMoved: false
                        };
                        
                        // Remove from captured pieces
                        const capturedColor = lastMove.color === 'white' ? 'black' : 'white';
                        const index = game.capturedPieces[capturedColor].indexOf(lastMove.capturedPiece);
                        if (index !== -1) {
                            game.capturedPieces[capturedColor].splice(index, 1);
                        }
                    } else {
                        game.board[lastMove.toRow][lastMove.toCol] = null;
                    }
                    
                    // Update king position if it was moved
                    if (lastMove.piece === 'king') {
                        game.kings[lastMove.color].row = lastMove.fromRow;
                        game.kings[lastMove.color].col = lastMove.fromCol;
                        
                        // Restore castling rights if this was the king's first move
                        if (!lastMove.hasMoved) {
                            game.castlingRights[lastMove.color].kingSide = true;
                            game.castlingRights[lastMove.color].queenSide = true;
                        }
                    }
                    
                    // Restore castling rights if this was a rook's first move from a corner
                    if (lastMove.piece === 'rook' && !lastMove.hasMoved) {
                        if (lastMove.fromRow === 0 && lastMove.fromCol === 0) {
                            game.castlingRights.black.queenSide = true;
                        } else if (lastMove.fromRow === 0 && lastMove.fromCol === 7) {
                            game.castlingRights.black.kingSide = true;
                        } else if (lastMove.fromRow === 7 && lastMove.fromCol === 0) {
                            game.castlingRights.white.queenSide = true;
                        } else if (lastMove.fromRow === 7 && lastMove.fromCol === 7) {
                            game.castlingRights.white.kingSide = true;
                        }
                    }
                }
                
                // Switch back to the previous player
                game.currentPlayer = lastMove.color;
                
                // Reset selection and check status
                game.selectedPiece = null;
                game.validMoves = [];
                game.inCheck = isKingInCheck(game.currentPlayer) ? game.currentPlayer : null;
                
                // Update last move
                game.lastMove = game.moveHistory.length > 0 ? 
                    game.moveHistory[game.moveHistory.length - 1] : null;
                
                renderBoard();
                showMessage("Move undone!");
                setTimeout(hideMessage, 2000);
            }

            // Flip the board orientation
            function flipBoard() {
                game.boardOrientation = game.boardOrientation === 'white' ? 'black' : 'white';
                renderBoard();
                showMessage(`Board flipped! ${game.boardOrientation.charAt(0).toUpperCase() + game.boardOrientation.slice(1)} is now at the bottom.`);
                setTimeout(hideMessage, 2000);
            }

            // Initialize the game
            function init() {
                // Initialize the board
                game.board = initializeBoard();
                
                // Render the board
                renderBoard();
                
                // Add event listeners
                resetButton.addEventListener('click', resetGame);
                undoButton.addEventListener('click', undoMove);
                flipButton.addEventListener('click', flipBoard);
                
                // Show welcome message
                showMessage("Welcome  White to move.");
                setTimeout(hideMessage, 3000);
            }
            
            // Start the game
            init();
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'962a434657562e7d',t:'MTc1MzA5NjM0MS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
